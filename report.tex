\documentclass[conference]{IEEEtran}
%\documentclass[12pt,a4paper,english]{report}
%\IEEEoverridecommandlockouts % The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\newcommand{\comment}[1]{}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Quantum-resistant digital signatures schemes for low-power IoT}

\author{\IEEEauthorblockN{1\textsuperscript{st} Hannes Hattenbach}
\IEEEauthorblockA{\textit{Computational Science} \\
\textit{Freie Universität}\\
Berlin, DE \\
hannes.hattenbach@fu-berlin.de}
}

\maketitle

\begin{abstract}
%*CRITICAL: Do Not Use Symbols, Special Characters, Footnotes, or Math in Paper Title or Abstract.
\end{abstract}

\begin{IEEEkeywords}
Internet of Things, Quantum Resistance, Secure Signatures, Power Constraint Devices
\end{IEEEkeywords}

%TODO 12 Seiten

\section{Introduction}
\comment{ %%%%%%%% NOTES %%%%%%%%%%%
„principles of data integrity, message authentication, and nonrepudiation, are going to have profound aftermath on sensory data in terms of security and privacy.“ \cite{QR_sigs}
} %%%%%%%%%%%%%%%% END %%%%%%%%%%%%%

The quantum revolution is coming. With quantum computers\footnote{compare section \ref{quantum_computing}} on the way to get more and more functional, people are fearing a loss of their security and privacy.
That is because there are algorithms based on Shors algorithm that can forge signatures and decrypt encrypted messages whos security is based on discrete logarithms, including elliptic curves or prime factoriztion, like our most common schemes ECDSA and RSA respectively are.
The quantum computer only needs access to the public keys of these asymetric schemes.
The expenditure to forge a signature\footnote{that is considered secure under normal circumstances 
%noTODO: more precise? Unforgeablu under chosen blabla
} with classic\footnote{we refer to classic if something is not directly leveraging entanglement or superposition} computers rises exponentially with increased key length, therefor beeing essentially unbreakable by classic computers.
A sufficient quantum computer on the other hand can derive a private key from a public key in polynomial time, therefor rendering these schemes broken.

That is why there are currently schemes under standarization\cite{PQClean-GH} that are based on other hard problems (not number theory) like so called lattice problems that cannot be that easily forged by quantum computers to save our privacy and security.

One of the use cases not directly comming to mind for the end user, but beeing as important non the less is signing sensitive sensor data in the Internet of Things (IoT).
Another problem coming up in the IoT compared to end-user-devices like Laptops and Smartphones though is the severe ressource contraintness. 
The IoT consist of low power devices with wery few storage and computing power.

In this paper i am going to evaluate existing signature schemes and their usage possibilities for the IoT regarding their performance metrics.

Therefor i am going to give a small introduction and background to quantum computing, beeing a little more detailed about their ability to break current encryption and signature standards.
In the next section i will give an overview over current candidates for Quantum Resistant (QR) Algorithms and giving performance metrics for those.
The following chapter will then focus on signature schemes in the IoT, starting with additional performance metrics relevant in the IoT.
With a little more details about two failed signature schmemes to highlight potetial pitfalls. 
And finally focussing on the best signature contenter for the IoT so far: FALCON.

\section{Cryptography}
% TODO : already distinguish between : hashing, encryption (symmetric/asymmetric), signatures
Loosely speaking the main topic of cryptography can be devided 

% noTODO ? Background section to put this in?
\section{Internet of Things}
\comment{ %%%%%%%% NOTES %%%%%%%%%%%
- growing: over 3 billion rn \cite{QR_IoT}
} %%%%%%%%%%%%%%%% END %%%%%%%%%%%%%

%discussion what the boundries of iot compare different devices from linux devices rPI over 32bit Arm based processors with RTOS to 8bit microcontrollers like arduino/atmega
The IoT consists of devices of all sorts, having in common, that they communicate with each other and the enviroment rather than directly with humans.
Those devices range from automatic lights and smart home devices to tiny interconnected sensors in automatic fabrication.
A common characteristic though is, that most of these devices have limited processing power, flash storage and random access memory (RAM). 
A popular example for hobbiest IoT devices is the ESP32 from Espressif Microsystems.
They offer multiple Modules with up to 240Mhz Clock on the 32 IC, up to 16MiB Flash Storage and 320KiB RAM.
Which is more than other compareable devices but way less then a lower spec modern smartphone, with 10 times the frequency, 4GB of RAM and 64GB of storage.

Since the IoT consists of very different types of constrained nodes the IETF introduced different classes on which to classify IoT nodes:\\
\vspace{.1 cm}
\begin{tabular}{l | c c}
    Class & RAM & Flash \\
    \hline
    C0 & $<<$ 10 KiB & $<<$ 100 KiB\\
    C1 & ~ 10 KiB & ~ 100 KiB\\
    C2 & ~ 50 KiB & ~ 250 KiB\\
    
\end{tabular}
\vspace{.1 cm}


\section{Quantum Resistant Security}
% TODO : Reference Shor and Grover
\subsection{Quantum Computing}\label{quantum_computing}
In contrast to classical computers, where information is processed in discete states, a quantum computer leverages quantum mechanics to operate on so-called qubits - quantum objects that can be in superposition or entangled with each other. 
Opening a new kind of computing. 
One of the implications of that is, that it is now possible to factor large numbers in polynomial time using an algorithm deverloped by Shor \cite{Shor}. 
This algorithm uses a so-called Quantum-Fourier-Transform (QFT) to (probablisticly) get the frequencys of which a given function output occurs. That can be used together with euclids algorithm of finding the greatest common devisor to derive the prime factors. 
Prior to to quantum computers this was considered a hard problem that could only be computed in exponential time and was therefor considered practically impossible and was used as the basis-problem for RSA encryption.
Similar to that other common schemes like ECDSA can also be broken be slightly modidied versions of Shors Algorithm.
\subsection{QR Algorithms}
The two main algorithms with practical use cases that have a great speed-up compared to classical solutions, are the already introduced algorithm by Shor and an algorithm by Grover taht can essentially reverse one-way functions.
While Shors algorithm provides exponential speed-up Grovers algorithm only provides quadratic speed up. It was also shown, that something similar to grovers algorithm but with exponential speedup is impossible \cite{Strengths&Weaknesses_QC}. Which implies that Hashing as well as symetric cryptography stays relatively secure.
The quadratic speedup provided by quantum computers can easily be mitigated by doubling the key length.
On the other hand though, classical asymetric cryptography is endangered by shors algorithm and quantum computers.

But not all asymetric cryptography schemes are equally affected.
There are different proposals, both for QR encryption and for QR signature schemes.
They all do have in common though, that their security is not absolutely mathematically prooven, but based upon assumptions.
We therefor need to consider a few measures that make schmemes more or less secure.
\subsubsection{Performance Metrics}
\comment{ %%%%%%%% NOTES %%%%%%%%%%%
- Security Level (1-5, AES-128, SHA256, AES-192, SHA384, AES-256) \cite{QR_Iot_Lattice,Energy_comp}([7]) determined via grovers alg
- no standard benchmark for quantum resistance \cite{QR_comparison} (nist levels 1-5)
} %%%%%%%%%%%%%%%% END %%%%%%%%%%%%%

Some performance metrics exist in QR schemes as well as in classic schemes.
Keylength and
key exchange message length \cite{QR_algs} are the more obvious ones.
The computing time also comes to mind as a perfomance metric. Here you need to differentiate between key generation, which is less important, since it should only occur rarely, and signing as well as signature verification \footnote{as well as its counterparts de- and encryption}.

Primarely in signatures another metric arises: how often can a private key be used before it needs to be switched out for another one, because the signature leaked information of the key.
This is not particularly relevant in most cases, as methods can be used to create long term procedures from short term procedures (those where a key can rarely, if ever, be recycled).
But it is relevant in the case of the IoT, since those methods require extra memory which is sparse in IoT-devices. Adiitionally they tend to make the signatures themself longer, which also is not preferrable in the IoT. \cite{QR_algs}

\subsubsection{Encryption}
\comment{ %%%%%%%% NOTES %%%%%%%%%%%
knapsack problem - broken
''
conjugacy search problem and related problems in braid groups, and the problem of solving
multivariate systems of polynomials in finite fields
'' also mostly broken or badly understood \cite{QR_algs}

lattice based:
- NTRUEncrypt (compare sigs)
code based:
- McEliece Error correction codes transformed - secure and fast (100micros) but keys are k*n matrices : millions of bits \cite{QR_algs} - not feasable 
multivariate-based: decryption inefficent (''guess work'') \cite{QR_comparison}
- Rainbow gigantic 22kbyte pubk
Supersingular EC:
not much in use and not super researched , one impl (SIKE) \cite{QR_comparison}
Mixed schemes for backwards comp: neither fully safe nor efficent since 2 schemes need to be saved on device \cite{QR_comparison}

mostly code/lattice based implementations \cite{QR_comparison}
} %%%%%%%%%%%%%%%% END %%%%%%%%%%%%%

\subsubsection{Signatures} 
\comment{ %%%%%%%% NOTES %%%%%%%%%%%

Signatures classify as
- Hash based
- Lattice based
- Multivariate polynomial based
- Code based
- Super-singular sogen based
\cite{QR_sigs}

hash based or lattice based:
- hash: XMSS, SPHINCS \cite{QR_IoT}
- lamport OT signature \cite{QR_algs} (as the name implies only useable one time - useless ; can precompute a bunch that are verifiable with the same pubk - useless since rare storage)
- lattice based signatures (high-d basis find shortest vector (SVP) or closest lattice vector to arbitrary point (CVP)) require megabits of basis - unfeasable NTRU reduce to kilobits by introducing symetry \cite{QR_algs,QR_comparison}
    -10-100* faster than conventional crypto
    Encryption : - vulnerable to CCA , lattice reduction techniques - padding scheme [30] , longer keys \cite{QR_algs}
    Signatures : - map message to vector, sign by solving (CVP) - leaks information about PrivK - broken after 400messages - dont give closest vektor but a close enough one - secure for 1 mrd (billion) sigs (still adviced to swap after 10mil) (okayish iniot since not so many massages)
    - proposals (2017: GPV, GLP, BLISS \cite{QR_IoT})

HBS vs Lattice:
    - SPHINCS (HBS) (intel XEON (wtf?!))
        - sign: 50mil clock cycles 
        - Ver: 1.6mil
        - Key-size: pub 1 ; private 1
        - Sig size: 41KB
    - BLISS (lattice) (arm M4)
        - 5.9mil
        - 1mil
        - 7; 2 (hm ouf)
        - 0.96

	HBS is well studied/understood/practiced lattice not and vulnerabilities discovered one after the other

	Stateful (wOTS, XMSS, LMS ..)
		„stateful digital signature scheme necessitates the main- tenance of the updated nonrepeated secret key upon each signature generation process. It is essential to keep track of nonrepeated key pairs, failing which will result in the degra- dation of the security of the cryptographic scheme“ ..sounds kinda whack to me

		MSS stores only prng seed and uses merkle trees -> managing state (used keys) on other side (because reusing key is imperative to security)

	Stateless(Sphincs)
		more expensive sig gen , since key pairs used in random order - BDS optimization no longer applicable

	Stateful if performance time and processor constrained, Stateless if energy/memory constrained
\cite{QR_sigs}


 code-based:   
- McEliece decrypt padded message digest - try thousands of paddings - signing takes 30seks, 4mb priv/pub KEY-size -not feasbale
} %%%%%%%%%%%%%%%% END %%%%%%%%%%%%%

\section{QR Signatures in IoT}
\comment{ %%%%%%%% NOTES %%%%%%%%%%%
Stack usage:
    name        & KeyGen    & Sign  & Verify
    Dilithium-3 & 50k       & 86k   & 54k
    qTESLA-1    & 22k       & 29k   & 23k
    qTESLA-3    & 43k       & 28k   & 45k
    Falcon-5    & 120k      & 120k  & 120k

Clock cycles (10mil ~ 60ms (ARM M4 (168Mhz))):
    name        & KeyGen    & Sign  & Verify
    Dilithium-3 & 2.3m      & 8.3m  & 2.3m
    Dilithium-3 & 2.1       & 7.2   & 2.1 \cite{Energy_comp}
    Falcon-5    & 365m      & 165m  & 1m
    qTESLA-3    & 30m       & 11m   & 2.2m
    \cite{QR_Iot_Lattice}

Hash-Based Sphincs promising since stateless, but many parameters to set \cite{QR_IoT_Energy}

as of \cite{QR_comparison} only schemes (out of ~50) with < 4kbit: SIKE and Round5 
} %%%%%%%%%%%%%%%% END %%%%%%%%%%%%%

\subsubsection{Performance Metrics in IoT}
\comment{ %%%%%%%% NOTES %%%%%%%%%%%
- key/ exchange message/ signature size 
- cache/ ram usage

- setup(ms)  lifetime, pubk size, privk size, sig

'' small sized public key, small digital 
signature and a range of supported hash output sizes is 
recommended''\cite{QR_Iot_Lattice}

- Stateful/less
- „signature and/or key sizes to running times and memory consumption to energy consumption „
- „From the software benchmark perspec- tive, the runtime of key generation, signing, and verification processes whereas from the hardware perspective, CPU cycles, key size, signature size, and energy consumption are among the targeted evaluation metrics. In general, the parameter sets are highly dependent on the underlying construction of a particular scheme.“
\cite{QR_sigs}

- most impls have quite large keys \cite{QR_comparison}
- key gen performance since many schemes have limited signatures \cite{QR_comparison}

- IoT evolves, when fast quantum is available iot will be better too  \cite{QR_comparison}
} %%%%%%%%%%%%%%%% END %%%%%%%%%%%%%


%\subsection{Failed Signatures}
\comment{ %%%%%%%% NOTES %%%%%%%%%%%
} %%%%%%%%%%%%%%%% END %%%%%%%%%%%%%

%\subsubsection{WalnutDSA}
\comment{ %%%%%%%% NOTES %%%%%%%%%%%
wahrscheinlich skippen da mir da hintergrund zu braid groups etc fehlt
} %%%%%%%%%%%%%%%% END %%%%%%%%%%%%%

\subsection{qTESLA}
\comment{ %%%%%%%% NOTES %%%%%%%%%%%
not in the endgame but also not broken afaik
} %%%%%%%%%%%%%%%% END %%%%%%%%%%%%%

\subsection{FALCON}
\comment{ %%%%%%%% NOTES %%%%%%%%%%%
falcon-512 (L1):
pubk/sig 897/690 bytes (dil3: 1472/2701 ecdsa: 64)
keygen: 182m clk , 118mJ (dil3: 2.3m / 1.7mJ ecdsa 5mJ)
sign/ver: 23.5/0.345 mJ (dil3 5mJ/1.7mJ ecdsa 4mJ)

falcon-1024 (L5):
pubk/sig 1793/1330 bytes
keygen: 380m clk , 232mJ
sign/ver: 45.5/0.69 mJ
\cite{Energy_comp}

} %%%%%%%%%%%%%%%% END %%%%%%%%%%%%%


\section{Conclusion}
\comment{ %%%%%%%% NOTES %%%%%%%%%%%
- of course no protection against side channel etc 
- quantum fast evolving, active field of research
- smart home, smart campus, smart city
- quantum key distribution
\cite{QR_comparison}
} %%%%%%%%%%%%%%%% END %%%%%%%%%%%%%

\bibliographystyle{IEEEtran}
\bibliography{lit.bib, lit_specific.bib}

\end{document}
